using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace Najlot.Map.SourceGenerator;

[Generator]
public class RegistrationGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Najlot.Map.Attributes.MappingAttribute";
    private const string AttributeShortName = "MappingAttribute";
    private const string AttributeNameWithoutSuffix = "Mapping";

    private const string IgnoreAttributeName = "Najlot.Map.Attributes.MapIgnoreMethodAttribute";
    private const string IgnoreAttributeShortName = "MapIgnoreMethodAttribute";
    private const string IgnoreAttributeNameWithoutSuffix = "MapIgnoreMethod";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration && classDeclaration.AttributeLists.Count > 0;
    }

    private static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is IMethodSymbol attributeSymbol)
                {
                    var attributeTypeName = attributeSymbol.ContainingType.ToDisplayString();
                    if (IsMappingAttribute(attributeTypeName))
                    {
                        return context.SemanticModel.GetDeclaredSymbol(classDeclaration);
                    }
                }
            }
        }

        return null;
    }

    private static bool IsMappingAttribute(string attributeTypeName)
    {
        return attributeTypeName == AttributeName
            || attributeTypeName.EndsWith("." + AttributeShortName)
            || attributeTypeName.EndsWith("." + AttributeNameWithoutSuffix);
    }

    private static void Execute(Compilation compilation, ImmutableArray<INamedTypeSymbol?> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        var distinctClasses = classes.Where(c => c is not null).Distinct(SymbolEqualityComparer.Default).Cast<INamedTypeSymbol>().ToList();
        if (distinctClasses.Count == 0)
        {
            return;
        }

        var assemblyName = compilation.AssemblyName ?? "Najlot.Map";
        var sanitizedAssemblyName = new string(assemblyName.Where(c => char.IsLetterOrDigit(c)).ToArray());
        var className = $"MapRegistrationExtensions_{sanitizedAssemblyName}";
        var methodName = $"Register{sanitizedAssemblyName}Mappings";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Najlot.Map;");
        sb.AppendLine();
        sb.AppendLine($"namespace {assemblyName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static class {className}");
        sb.AppendLine("    {");
        sb.AppendLine($"        public static IMap {methodName}(this IMap map)");
        sb.AppendLine("        {");

        foreach (var classSymbol in distinctClasses)
        {
            GenerateRegistrationForClass(classSymbol, sb);
        }

        sb.AppendLine("            return map;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource($"{className}.g.cs", sb.ToString());
    }

    private static void GenerateRegistrationForClass(INamedTypeSymbol classSymbol, StringBuilder sb)
    {
        var methods = classSymbol.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.DeclaredAccessibility == Accessibility.Public && !m.IsGenericMethod)
            .ToList();

        if (methods.Count == 0)
        {
            return;
        }

        var instanceName = $"instance_{classSymbol.ToDisplayString().Replace(".", "_").Replace("<", "_").Replace(">", "_")}";
        var hasInstanceMethods = false;
        var registrationCalls = new List<string>();

        foreach (var method in methods)
        {
            if (IsIgnoredMethod(method))
            {
                continue;
            }

            if (TryGetMappingTypes(method, out var fromType, out var toType))
            {
                var methodAccess = method.IsStatic ? $"{classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{method.Name}" : $"{instanceName}.{method.Name}";
                
                if (!method.IsStatic)
                {
                    hasInstanceMethods = true;
                }

                registrationCalls.Add($"            map.Register<{fromType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}, {toType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>({methodAccess});");
            }
            else if (TryGetExpressionMappingTypes(method, out var exprFromType, out var exprToType))
            {
                var methodAccess = method.IsStatic ? $"{classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{method.Name}()" : $"{instanceName}.{method.Name}()";

                if (!method.IsStatic)
                {
                    hasInstanceMethods = true;
                }

                registrationCalls.Add($"            map.RegisterExpression<{exprFromType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}, {exprToType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>({methodAccess});");
            }
        }

        if (registrationCalls.Count > 0)
        {
            if (hasInstanceMethods)
            {
                sb.AppendLine($"            var {instanceName} = map.Create<{classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();");
            }

            foreach (var call in registrationCalls)
            {
                sb.AppendLine(call);
            }
        }
    }

    private static bool IsIgnoredMethod(IMethodSymbol method)
    {
        foreach (var attr in method.GetAttributes())
        {
            var attrName = attr.AttributeClass?.ToDisplayString();
            if (attrName != null && (attrName == IgnoreAttributeName || attrName.EndsWith("." + IgnoreAttributeShortName) || attrName.EndsWith("." + IgnoreAttributeNameWithoutSuffix)))
            {
                return true;
            }
        }
        return false;
    }

    private static bool TryGetMappingTypes(IMethodSymbol method, out ITypeSymbol? fromType, out ITypeSymbol? toType)
    {
        fromType = null;
        toType = null;

        if (method.ReturnsVoid)
        {
            // void Method(TFrom, TTo)
            // void Method(IMap, TFrom, TTo)
            if (method.Parameters.Length == 2)
            {
                fromType = method.Parameters[0].Type;
                toType = method.Parameters[1].Type;
                return true;
            }
            else if (method.Parameters.Length == 3 && IsIMap(method.Parameters[0].Type))
            {
                fromType = method.Parameters[1].Type;
                toType = method.Parameters[2].Type;
                return true;
            }
        }
        else
        {
            // TTo Method(TFrom)
            // TTo Method(IMap, TFrom)
            if (method.Parameters.Length == 1)
            {
                fromType = method.Parameters[0].Type;
                toType = method.ReturnType;
                return true;
            }
            else if (method.Parameters.Length == 2 && IsIMap(method.Parameters[0].Type))
            {
                fromType = method.Parameters[1].Type;
                toType = method.ReturnType;
                return true;
            }
        }

        return false;
    }

    private static bool IsIMap(ITypeSymbol type)
    {
        return type.Name == "IMap" && (type.ContainingNamespace?.Name == "Map" || type.ToDisplayString() == "Najlot.Map.IMap");
    }

    private static bool TryGetExpressionMappingTypes(IMethodSymbol method, out ITypeSymbol? fromType, out ITypeSymbol? toType)
    {
        fromType = null;
        toType = null;

        if (method.Parameters.Length != 0)
        {
            return false;
        }

        var returnType = method.ReturnType as INamedTypeSymbol;
        if (returnType == null || !returnType.IsGenericType || returnType.Name != "Expression")
            return false;

        // Check namespace System.Linq.Expressions
        if (returnType.ContainingNamespace?.ToDisplayString() != "System.Linq.Expressions")
            return false;

        var funcType = returnType.TypeArguments[0] as INamedTypeSymbol;
        if (funcType == null || !funcType.IsGenericType || funcType.Name != "Func")
            return false;

        if (funcType.TypeArguments.Length == 2)
        {
            fromType = funcType.TypeArguments[0];
            toType = funcType.TypeArguments[1];
            return true;
        }

        return false;
    }
}
